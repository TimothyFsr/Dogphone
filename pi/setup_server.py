#!/usr/bin/env python3
"""
DogPhone setup web server – runs when device has no config.
Serves wizard UI with QR code; collects WiFi (optional) and Telegram; writes config.
"""
import json
import logging
import os
import re
import subprocess
import sys
from pathlib import Path

sys.path.insert(0, str(Path(__file__).resolve().parent))

from config import load_config

logging.basicConfig(level=logging.INFO, format="%(message)s")
log = logging.getLogger("setup")

try:
    from flask import Flask, request, jsonify, send_from_directory
    HAS_FLASK = True
except ImportError:
    HAS_FLASK = False
    Flask = None

REPO_ROOT = Path(__file__).resolve().parent.parent
CONFIG_FILE = REPO_ROOT / "config" / "config.env"
SETUP_HTML = Path(__file__).resolve().parent / "setup_wizard.html"

# nmcli hotspot uses 10.42.0.1 by default; some setups use 192.168.4.1
SETUP_AP_IP_DEFAULT = "10.42.0.1"
SETUP_AP_IP_LEGACY = "192.168.4.1"


def get_setup_url() -> str:
    """URL the phone should open when connected to DogPhone-Setup WiFi."""
    port = load_config().get("setup_port", 8765)
    # Prefer actual IP of this machine on the hotspot interface (when Pi is the AP)
    try:
        import subprocess
        out = subprocess.check_output(
            ["ip", "-4", "-o", "addr", "show", "scope", "global"],
            text=True, timeout=2,
        )
        for line in out.strip().splitlines():
            # Format: 2: wlan0 inet 10.42.0.1/24 ...
            parts = line.split()
            if len(parts) >= 4 and parts[2] == "inet":
                ip = parts[3].split("/")[0]
                if ip.startswith("10.42.") or ip.startswith("192.168."):
                    return f"http://{ip}:{port}"
    except Exception:
        pass
    return f"http://{SETUP_AP_IP_DEFAULT}:{port}"


def write_config(updates: dict) -> None:
    """Merge updates into config.env (create file if missing)."""
    CONFIG_FILE.parent.mkdir(parents=True, exist_ok=True)
    existing = {}
    if CONFIG_FILE.exists():
        with open(CONFIG_FILE) as f:
            for line in f:
                m = re.match(r"^([A-Za-z_][A-Za-z0-9_]*)=(.*)$", line.strip())
                if m:
                    existing[m.group(1)] = m.group(2).strip()
    for k, v in updates.items():
        if v is not None:
            existing[k] = str(v).strip()
    with open(CONFIG_FILE, "w") as f:
        f.write("# DogPhone – generated by setup\n")
        for k, v in sorted(existing.items()):
            f.write(f"{k}={v}\n")
    log.info("Wrote config: %s", CONFIG_FILE)


def fetch_chat_id(token: str) -> tuple[str | None, str | None]:
    """Get latest chat id from Telegram getUpdates. Returns (chat_id, error_type)."""
    try:
        import requests
        r = requests.get(
            f"https://api.telegram.org/bot{token}/getUpdates",
            timeout=10,
        )
        data = r.json()
        if not data.get("ok"):
            return None, "invalid_token"
        for u in reversed(data.get("result", [])):
            msg = u.get("message") or u.get("edited_message")
            if msg and "chat" in msg:
                return str(msg["chat"]["id"]), None
        return None, "no_updates"
    except requests.exceptions.Timeout:
        log.warning("getUpdates timeout (Pi may have no internet when on hotspot)")
        return None, "network_error"
    except requests.exceptions.RequestException as e:
        log.warning("getUpdates request failed: %s", e)
        return None, "network_error"
    except Exception as e:
        log.warning("getUpdates failed: %s", e)
        return None, "network_error"


def connect_wifi(ssid: str, password: str) -> bool:
    """Try to connect Pi to WiFi using nmcli (Raspberry Pi OS Bookworm)."""
    if not ssid or not ssid.strip():
        return False
    try:
        subprocess.run(
            [
                "nmcli", "device", "wifi", "connect",
                ssid.strip(),
                "password", password,
            ],
            capture_output=True,
            text=True,
            timeout=30,
        )
        return True
    except Exception as e:
        log.warning("nmcli connect failed: %s", e)
    return False


def create_app():
    app = Flask(__name__)

    @app.route("/")
    def index():
        return send_setup_html()

    @app.route("/setup")
    def setup():
        return send_setup_html()

    def send_setup_html():
        if SETUP_HTML.exists():
            return send_from_directory(SETUP_HTML.parent, SETUP_HTML.name)
        return "<h1>Setup</h1><p>Place setup_wizard.html in the pi/ folder.</p>", 404

    def has_internet() -> bool:
        try:
            import urllib.request
            urllib.request.urlopen("https://api.telegram.org", timeout=3)
            return True
        except Exception:
            return False

    @app.route("/api/status")
    def api_status():
        cfg = load_config()
        port = cfg.get("setup_port", 8765)
        setup_url = get_setup_url()
        alternate_urls = [
            f"http://{SETUP_AP_IP_DEFAULT}:{port}",
            f"http://{SETUP_AP_IP_LEGACY}:{port}",
        ]
        video_ok = bool(cfg.get("video_call_url"))
        return jsonify({
            "setup_url": setup_url,
            "alternate_urls": [u for u in alternate_urls if u != setup_url],
            "has_internet": has_internet(),
            "has_video_url": video_ok,
            "ready": video_ok,
        })

    @app.route("/api/wifi", methods=["POST"])
    def api_wifi():
        data = request.get_json() or {}
        ssid = (data.get("ssid") or "").strip()
        password = (data.get("password") or "")
        if not ssid:
            return jsonify({"ok": False, "error": "WiFi name required"}), 400
        if connect_wifi(ssid, password):
            try:
                subprocess.Popen(
                    ["sudo", "reboot"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                )
            except Exception:
                pass
            return jsonify({"ok": True, "reboot": True})
        return jsonify({"ok": False, "error": "Connection failed. Try again."}), 400

    @app.route("/api/video_url", methods=["POST"])
    def api_video_url():
        data = request.get_json() or {}
        url = (data.get("video_call_url") or "").strip()
        if not url:
            return jsonify({"ok": False, "error": "Zoom Meeting ID or URL required"}), 400
        password = (data.get("video_call_password") or "").strip()
        updates = {"VIDEO_CALL_URL": url}
        if password:
            updates["VIDEO_CALL_PASSWORD"] = password
        else:
            # Remove password if cleared
            updates["VIDEO_CALL_PASSWORD"] = ""
        write_config(updates)
        return jsonify({"ok": True})

    @app.route("/exit")
    def exit_page():
        """Show how to close the full-screen app."""
        return (
            "<!DOCTYPE html><html><head><meta name='viewport' content='width=device-width,initial-scale=1'>"
            "<title>Close DogPhone</title></head><body style='font-family:sans-serif;padding:2rem;max-width:400px;margin:0 auto;'>"
            "<h1>Close DogPhone</h1>"
            "<p><strong>With a USB keyboard:</strong> Press <kbd>Alt</kbd>+<kbd>F4</kbd> to close this window.</p>"
            "<p><strong>Without keyboard:</strong> From another computer on the same network, SSH in and run: <code>pkill chromium</code></p>"
            "<p><a href='/setup'>← Back to setup</a></p>"
            "</body></html>"
        )

    @app.route("/api/update", methods=["POST"])
    def api_update():
        """Pull latest from GitHub (https://github.com/TimothyFsr/Dogphone)."""
        try:
            from update_check import run_update
            ok, msg = run_update()
            return jsonify({"ok": ok, "message": msg})
        except Exception as e:
            return jsonify({"ok": False, "message": str(e)[:300]})

    @app.route("/api/complete", methods=["POST"])
    def api_complete():
        # Reboot so device starts in normal (main app) mode
        try:
            subprocess.Popen(
                ["sudo", "reboot"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
        except Exception:
            pass
        return jsonify({"ok": True, "reboot": True})

    return app


def main():
    if not HAS_FLASK:
        log.error("Install Flask: pip install flask")
        sys.exit(1)
    cfg = load_config()
    port = cfg.get("setup_port", 8765)
    url = get_setup_url()
    log.info("Setup server at %s", url)
    create_app().run(host="0.0.0.0", port=port, debug=False, threaded=True)


if __name__ == "__main__":
    main()
